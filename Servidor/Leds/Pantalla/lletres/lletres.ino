#include <stdlib.h>


//https://github.com/adafruit/Adafruit_NeoMatrix
// Only use this functions or Serial will not work:
//https://github.com/adafruit/Adafruit_NeoMatrix/blob/master/Adafruit_NeoMatrix.h
#include <Adafruit_GFX.h>
#include <Adafruit_NeoMatrix.h>
#include <Adafruit_NeoPixel.h>



#include "smileytongue24.h"

//generated by the other program. You cal also use main Adafruit letters (less dificult)
#include "fontProgmem.h"

#define PIN 10
#define MATRIU_WIDTH 29
#define MATRIU_HEIGHT 10

//ALERT: DEFAULT VALUE IS 9600
#define SERIAL_BAUD 115200






//screenOffset must be ONE less than the bigest width letter
#define screenOffset 12
byte posScreen = 0;
int screen[MATRIU_WIDTH + screenOffset];


//Cadena de caracters rebuda per el USB
String inputString = "";         // a String to hold incoming data
bool stringComplete = false;     // whether the string is complete

//When i found a char to write, i will store there
int  fontAEscriure[13];
byte ampladaFontAEscriure;


#define LED_BLACK    0

#define LED_RED_VERYLOW   (3 <<  11)
#define LED_RED_LOW     (7 <<  11)
#define LED_RED_MEDIUM    (15 << 11)
#define LED_RED_HIGH    (31 << 11)

#define LED_GREEN_VERYLOW (1 <<  5)
#define LED_GREEN_LOW     (15 << 5)
#define LED_GREEN_MEDIUM  (31 << 5)
#define LED_GREEN_HIGH    (63 << 5)

#define LED_BLUE_VERYLOW  3
#define LED_BLUE_LOW    7
#define LED_BLUE_MEDIUM   15
#define LED_BLUE_HIGH     31

#define LED_ORANGE_VERYLOW  (LED_RED_VERYLOW + LED_GREEN_VERYLOW)
#define LED_ORANGE_LOW    (LED_RED_LOW     + LED_GREEN_LOW)
#define LED_ORANGE_MEDIUM (LED_RED_MEDIUM  + LED_GREEN_MEDIUM)
#define LED_ORANGE_HIGH   (LED_RED_HIGH    + LED_GREEN_HIGH)

#define LED_PURPLE_VERYLOW  (LED_RED_VERYLOW + LED_BLUE_VERYLOW)
#define LED_PURPLE_LOW    (LED_RED_LOW     + LED_BLUE_LOW)
#define LED_PURPLE_MEDIUM (LED_RED_MEDIUM  + LED_BLUE_MEDIUM)
#define LED_PURPLE_HIGH   (LED_RED_HIGH    + LED_BLUE_HIGH)

#define LED_CYAN_VERYLOW  (LED_GREEN_VERYLOW + LED_BLUE_VERYLOW)
#define LED_CYAN_LOW    (LED_GREEN_LOW     + LED_BLUE_LOW)
#define LED_CYAN_MEDIUM   (LED_GREEN_MEDIUM  + LED_BLUE_MEDIUM)
#define LED_CYAN_HIGH   (LED_GREEN_HIGH    + LED_BLUE_HIGH)

#define LED_WHITE_VERYLOW (LED_RED_VERYLOW + LED_GREEN_VERYLOW + LED_BLUE_VERYLOW)
#define LED_WHITE_LOW   (LED_RED_LOW     + LED_GREEN_LOW     + LED_BLUE_LOW)
#define LED_WHITE_MEDIUM  (LED_RED_MEDIUM  + LED_GREEN_MEDIUM  + LED_BLUE_MEDIUM)
#define LED_WHITE_HIGH    (LED_RED_HIGH    + LED_GREEN_HIGH    + LED_BLUE_HIGH)




Adafruit_NeoMatrix *matrix = new Adafruit_NeoMatrix(MATRIU_WIDTH, MATRIU_HEIGHT, PIN,
    //NEO_MATRIX_BOTTOM     + NEO_MATRIX_RIGHT +
    NEO_MATRIX_TOP     + NEO_MATRIX_LEFT +
    NEO_MATRIX_COLUMNS + NEO_MATRIX_ZIGZAG,
    NEO_GRB            + NEO_KHZ800);
//const uint16_t colors[] = {  matrix->Color(255, 0, 0), matrix->Color(0, 255, 0), matrix->Color(0, 0, 255) };

//Foreground, background, aux1, aux2
uint16_t colors[4] = {LED_WHITE_HIGH, LED_BLACK, LED_GREEN_HIGH, LED_RED_HIGH};




static const uint16_t PROGMEM
// These bitmaps were written for a backend that only supported
// 4 bits per color with Blue/Green/Red ordering while neomatrix
// uses native 565 color mapping as RGB.
// I'm leaving the arrays as is because it's easier to read
// which color is what when separated on a 4bit boundary
// The demo code will modify the arrays at runtime to be compatible
// with the neomatrix color ordering and bit depth.
RGB_bmp[][64] = {
  // 0: multicolor smiley face
  { 0x000, 0x000, 0x00F, 0x00F, 0x00F, 0x00F, 0x000, 0x000,
    0x000, 0x00F, 0x000, 0x000, 0x000, 0x000, 0x00F, 0x000,
    0x00F, 0x000, 0xF00, 0x000, 0x000, 0xF00, 0x000, 0x00F,
    0x00F, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x00F,
    0x00F, 0x000, 0x0F0, 0x000, 0x000, 0x0F0, 0x000, 0x00F,
    0x00F, 0x000, 0x000, 0x0F4, 0x0F3, 0x000, 0x000, 0x00F,
    0x000, 0x00F, 0x000, 0x000, 0x000, 0x000, 0x00F, 0x000,
    0x000, 0x000, 0x00F, 0x00F, 0x00F, 0x00F, 0x000, 0x000,
  },
};


static const uint16_t PROGMEM GAY[] = {
  0x00F,
  0x08F,
  0x0DF,
  0x0F0,
  0xF00,
  0xD0D,
};

static const uint16_t PROGMEM CATALUNYA[] = {
  0x0DF,
  0x00F,
  0x0DF,
  0x00F,
  0x0DF,
  0x00F,
  0x0DF,
  0x00F,
  0x0DF,
};

static const uint16_t PROGMEM CATALUNYA_ESTEL[] = {
  0xF00,  0xF00,  0x0DF,  0x0DF,  0x0DF,  0x0DF,  0x0DF,  0x0DF,  0x0DF,
  0xF00,  0xF00,  0xF00,  0xF00,  0x00F,  0x00F,  0x00F,  0x00F,  0x00F,
  0xF00,  0xF00,  0xF00,  0xF00,  0xF00,  0xF00,  0x0DF,  0x0DF,  0x0DF,
  0xF00,  0xF00,  0xFFF,  0xFFF,  0xF00,  0xF00,  0xF00,  0x00F,  0x00F,
  0xF00,  0xFFF,  0xFFF,  0xFFF,  0xFFF,  0xF00,  0xF00,  0xF00,  0xF00,
  0xF00,  0xF00,  0xFFF,  0xFFF,  0xF00,  0xF00,  0xF00,  0x00F,  0x00F,
  0xF00,  0xF00,  0xF00,  0xF00,  0xF00,  0x0DF,  0x0DF,  0x0DF,  0x0DF,
  0xF00,  0xF00,  0xF00,  0xF00,  0x00F,  0x00F,  0x00F,  0x00F,  0x00F,
  0xF00,  0xF00,  0x0DF,  0x0DF,  0x0DF,  0x0DF,  0x0DF,  0x0DF,  0x0DF,
};


static const boolean rellotge[][10] = {
  { true, true, true, true, false,  false,  true, true, true, true, },
  { true, true, false,  false,  true, true, false,  false,  true, true, },
  { true, false,  true, true, false,  true, true, true, false,  true, },
  { true, false,  true, true, false,  true, true, true, false,  true, },
  { false,  true, true, true, false,  true, true, true, true, false,  },
  { false,  true, true, true, false,  false,  false,  true, true, false,  },
  { true, false,  true, true, true, true, true, true, false,  true, },
  { true, false,  true, true, true, true, true, true, false,  true, },
  { true, true, false,  false,  true, true, false,  false,  true, true, },
  { true, true, true, true, false,  false,  true, true, true, true, },
};

/*

*/
void init_neomatrix() {

  matrix->begin();
  //matrix->setFont(&TomThumb);
  matrix->setTextWrap(false);
  matrix->setBrightness(10);
  //Show withe screen for 3 secons to ensure all is ok at init
  matrix->fillScreen(LED_WHITE_HIGH);
  matrix->show();
  delay(1000);
  matrix->clear();
  matrix->show();


}

/*
  #include <Fonts/TomThumb.h>
  int x = MATRIU_WIDTH;
  int pass = 0;
  //
  // Example of how to write using  nomatrix font
  //
  void iteracio_neomatrix(String pText, uint16_t llargada) {

  matrix->fillScreen(0);
  matrix->setCursor(x, 1);
  //matrix->setTextSize(1);
  //matrix->print(F("P E R E     M I Q U E L"));
  matrix->print(pText);
  //if (--x < int(sizeof("P E R E     M I Q U E L"))*int(-5)) {
  //if (--x < int(sizeof(pText)*int(-5))) {
  if (--x < -int(llargada)) {
    x = matrix->width();
    if (++pass >= 3) pass = 0;
    matrix->setTextColor(colors[pass]);
  }
  matrix->show();
  delay(100);

  }
*/





/*

*/
void setup() {

  Serial.begin(SERIAL_BAUD);

  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }

  init_neomatrix();

  Serial.println("Inicialització realitzada");
  /*for (int i = 127; i < 255; i++) {
    Serial.print(i);
    Serial.print(" ");
    Serial.write(i);
    }*/
  /*String caracters="àèìòùáéíóúüçÀÈÌÒÙÁÉÍÓÚÜçÑñ";
    for (int i = 0; i < caracters.length(); i++) {
    Serial.print(i);
    Serial.print(" ");
    Serial.print(caracters.substring(i,i+1));
    Serial.print(" ");
    //Serial.println(int(caracters.substring(i,i+1)));
    }*/

}



/*
  int iteracio = 0;
  String cadenes[] = {"cat:", ":gay", "t:PERE", "t:MIQUEL", "smile:"};
*/
/*-------------------------------------------------------------
                 MAIN FUNCTION
  -------------------------------------------------------------
*/
void loop() {
  /*
    if (iteracio == 1 or iteracio == 2) delay(4000);
    inputString = cadenes[iteracio++];
    stringComplete = true;
    if (iteracio == 4) iteracio = 0;
  */

  if (not stringComplete){
    //Mirem si ha arribat alguna comanada per USB a executar
    EventUSB();

    
  }else {
    stringComplete = false;

    Serial.println(inputString);
    //COLOR EN PRIMER PLA
/*    if (inputString.substring(0, 3).equals("cf:")) {
      colors[0] = llegirColor(inputString.substring(3));

    //COLOR EN BACKGROUND
    }else if (inputString.substring(0, 3).equals("cb:")) {
      colors[1] = llegirColor(inputString.substring(3));

    //COLOR AUXILIAR
    }else if (inputString.substring(0, 4).equals("ca1:") )  {
      colors[2] = llegirColor(inputString.substring(4));

    //COLOR AUXILIAR
    }else if (inputString.substring(0, 4).equals("ca2:") )  {
      colors[3] = llegirColor(inputString.substring(4));

    //Emplena la pantalla amb el color de fondo
    } else */if (inputString.substring(0, 5).equals("fill:")) {
      matrix->fillScreen(colors[1]);
      matrix->show();


    //WRITE A TEXT
    }else if (inputString.substring(0, 2).equals("t:")) {
      Serial.println("Rebut text");
      String enviarString = inputString.substring(2);
      inputString = "";
      writeText(enviarString);

      //If don't have a new instruction that cuts this one
      if (!stringComplete) {
        //ask for more text
        Serial.println("+");
      }


      //COUNTDOWN
    } else if (inputString.substring(0, 3).equals("cd:")) {
      CompteEnrere();


    } else if (inputString.substring(0, 6).equals("smile:")) {
      Serial.println("Rebut smile");
      inputString = "";
      display_panOrBounceBitmap(8);


    } else if (inputString.substring(0, 4).equals("gay:")) {
      Serial.println("Rebut Gay");
      inputString = "";
      matrix->fillScreen(colors[1]);
      for (int colunes = 0; colunes < MATRIU_WIDTH; colunes++) {
        fixdrawRGBBitmap(colunes, 2, GAY, 1, 6);
      }
      matrix->show();

    } else if (inputString.substring(0, 4).equals("cat:")) {
      Serial.println("Rebut Catalunya");
      inputString = "";
      matrix->fillScreen(0);
      for (int colunes = 2; colunes < MATRIU_WIDTH; colunes++) {
        fixdrawRGBBitmap(colunes, 0, CATALUNYA, 1, 9);
      }
      fixdrawRGBBitmap(0, 0, CATALUNYA_ESTEL, 9, 9);

      matrix->show();



      /*    } else if (inputString.substring(0, 3).equals("tf:")) {
            String enviarString = inputString.substring(3);
            Serial.println("Rebut text fix " + enviarString);
            inputString = "";

            int16_t  x1, y1;
            uint16_t llargada, h;
            matrix->getTextBounds(enviarString, 0, 0, &x1, &y1, &llargada, &h);
            Serial.print("Té una amplada de ");
            Serial.println(llargada);

            if (llargada <= MATRIU_WIDTH) {
              matrix->fillScreen(0);
              matrix->setCursor(int((MATRIU_WIDTH - llargada) / 2), 1);
              matrix->print(enviarString);
              matrix->show();
            } else {
              while (true) {
                iteracio_neomatrix(enviarString, llargada);
                if (EventUSB()) {
                  break;
                }
              }
            }*/



    } else {
      Serial.println("Rebut desconegut");
      Serial.println(inputString);
    }
  }


}



//-------------------------------------------------------------
//-------------------------------------------------------------
//-------------------------------------------------------------
//-------------------------------------------------------------

/*
uint16_t llegirColor(String NouColor){

    int valorR=0;
    int valorG=0;
    int valorB=0;
    
    int n = sscanf(NouColor.c_str(), "%d,%d,%d", &valorR, &valorG, &valorB);
    return matrix->Color(valorR,valorG,valorB);
}
*/

//-------------------------------------------------------------
//-------------------------------------------------------------
//-------------------------------------------------------------
//-------------------------------------------------------------




void CompteEnrere(){
      for (int numero = 9 ; numero > 0; numero --) {
        String text = (String) numero;
        if (cercarFont(text[0])) {

          //Esborrar buffer screen
          for (byte i = 0; i < MATRIU_WIDTH + screenOffset ; i++) {        screen[i] = 0;      }

          //Encuar font i centrar font ampladaFontAEscriure
          for (byte i = 0; i < ampladaFontAEscriure; i++) {
            screen[((MATRIU_WIDTH - ampladaFontAEscriure) / 2) + 1 + i] = fontAEscriure[i];
          }

          escriureScreenLedStrip();
        }

        delay(600);
        
        //Dibuixem un rellotge durant 0.2 segons. La última iteració no ho fem. Utilitzem el color auxiliar
        if (numero>1){
          matrix->fillScreen(0);
          for (byte i = 0; i < 10; i++) {
            for (byte j = 0; j < 10; j++) {
              if (not rellotge[j][i])     matrix->drawPixel(        ((MATRIU_WIDTH - 10) / 2) + 1 + i,           j,             colors[2]  );
            }
          }
          matrix->show();
        }
        delay(300);

        matrix->fillScreen(colors[1]);
        matrix->show();
        delay(100);

        
        if (EventUSB()) {
          for (byte i = 0; i < MATRIU_WIDTH + screenOffset ; i++) {        screen[i] = 0;      }
          break;
        }

      }
      for (byte i = 0; i < MATRIU_WIDTH + screenOffset ; i++) {        screen[i] = 0;      }
}



//-------------------------------------------------------------
//-------------------------------------------------------------
//-------------------------------------------------------------
//-------------------------------------------------------------




// Scroll within big bitmap so that all if it becomes visible or bounce a small one.
// If the bitmap is bigger in one dimension and smaller in the other one, it will
// be both panned and bounced in the appropriate dimensions.
void display_panOrBounceBitmap (uint8_t bitmapSize) {
  // keep integer math, deal with values 16 times too big
  // start by showing upper left of big bitmap or centering if the display is big
  int16_t xf = max(0, (MATRIU_WIDTH - bitmapSize) / 2) << 4;
  int16_t yf = max(0, (MATRIU_HEIGHT - bitmapSize) / 2) << 4;
  // scroll speed in 1/16th
  const int16_t xfc = 6;
  const int16_t yfc = 3;
  // scroll down and right by moving upper left corner off screen
  // more up and left (which means negative numbers)
  int16_t xfdir = -1;
  int16_t yfdir = -1;

  for (uint16_t i = 1; i < 500; i++) {
    bool updDir = false;

    // Get actual x/y by dividing by 16.
    int16_t x = xf >> 4;
    int16_t y = yf >> 4;

    matrix->clear();
    // bounce 8x8 tri color smiley face around the screen
    if (bitmapSize == 8) fixdrawRGBBitmap(x, y, RGB_bmp[0], 8, 8);
/*    // pan 24x24 pixmap
    if (bitmapSize == 24) matrix->drawRGBBitmap(x, y, (const uint16_t *) bitmap24, bitmapSize, bitmapSize);
#ifdef BM32
    if (bitmapSize == 32) matrix->drawRGBBitmap(x, y, (const uint16_t *) bitmap32, bitmapSize, bitmapSize);
#endif*/
    matrix->show();

    // Only pan if the display size is smaller than the pixmap
    // but not if the difference is too small or it'll look bad.
    if (bitmapSize - MATRIU_WIDTH > 2) {
      xf += xfc * xfdir;
      if (xf >= 0)                      {
        xfdir = -1;
        updDir = true ;
      };
      // we don't go negative past right corner, go back positive
      if (xf <= ((MATRIU_WIDTH - bitmapSize) << 4)) {
        xfdir = 1;
        updDir = true ;
      };
    }
    if (bitmapSize - MATRIU_HEIGHT > 2) {
      yf += yfc * yfdir;
      // we shouldn't display past left corner, reverse direction.
      if (yf >= 0)                      {
        yfdir = -1;
        updDir = true ;
      };
      if (yf <= ((MATRIU_HEIGHT - bitmapSize) << 4)) {
        yfdir = 1;
        updDir = true ;
      };
    }
    // only bounce a pixmap if it's smaller than the display size
    if (MATRIU_WIDTH > bitmapSize) {
      xf += xfc * xfdir;
      // Deal with bouncing off the 'walls'
      if (xf >= (MATRIU_WIDTH - bitmapSize) << 4) {
        xfdir = -1;
        updDir = true ;
      };
      if (xf <= 0)           {
        xfdir =  1;
        updDir = true ;
      };
    }
    if (MATRIU_HEIGHT > bitmapSize) {
      yf += yfc * yfdir;
      if (yf >= (MATRIU_HEIGHT - bitmapSize) << 4) {
        yfdir = -1;
        updDir = true ;
      };
      if (yf <= 0)           {
        yfdir =  1;
        updDir = true ;
      };
    }



    //if (updDir) {
    // Add -1, 0 or 1 but bind result to 1 to 1.
    // Let's take 3 is a minimum speed, otherwise it's too slow.
    //  xfc = constrain(xfc + random(-1, 2), 3, 16);
    //  yfc = constrain(xfc + random(-1, 2), 3, 16);
    //}
    delay(30);
 
  }
}

// Convert a BGR 4/4/4 bitmap to RGB 5/6/5 used by Adafruit_GFX
void fixdrawRGBBitmap(int16_t x, int16_t y, const uint16_t *bitmap, int16_t w, int16_t h) {
  // work around "a15 cannot be used in asm here" compiler bug when using an array on ESP8266
  // uint16_t RGB_bmp_fixed[w * h];
  static uint16_t *RGB_bmp_fixed = (uint16_t *) malloc( w * h * 2);
  for (uint16_t pixel = 0; pixel < w * h; pixel++) {
    uint8_t r, g, b;
    uint16_t color = pgm_read_word(bitmap + pixel);

    //Serial.print(color, HEX);
    b = (color & 0xF00) >> 8;
    g = (color & 0x0F0) >> 4;
    r = color & 0x00F;
    //Serial.print(" ");
    //Serial.print(b);
    //Serial.print("/");
    //Serial.print(g);
    //Serial.print("/");
    //Serial.print(r);
    //Serial.print(" -> ");
    // expand from 4/4/4 bits per color to 5/6/5
    b = map(b, 0, 15, 0, 31);
    g = map(g, 0, 15, 0, 63);
    r = map(r, 0, 15, 0, 31);
    //Serial.print(r);
    //Serial.print("/");
    //Serial.print(g);
    //Serial.print("/");
    //Serial.print(b);
    RGB_bmp_fixed[pixel] = (r << 11) + (g << 5) + b;
    //Serial.print(" -> ");
    //Serial.println(RGB_bmp_fixed[pixel], HEX);
  }
  matrix->drawRGBBitmap(x, y, RGB_bmp_fixed, w, h);
}



//-------------------------------------------------------------
//-------------------------------------------------------------
//-------------------------------------------------------------
//-------------------------------------------------------------



void writeText(String pFraseRebuda) {

  for (auto i : pFraseRebuda)  {
    if (cercarFont((char)i)) {
      encuarFontScreen();
      while (posScreen > 0) {
        //Only for debug
        //escriureScreenUSB();
        escriureScreenLedStrip();
        ferCorrerScreen();
        delay(50);
      }

      if (EventUSB()) {
        break;
      }
    }
  }
  //move last caracter until the end, althought another instruction arribes
  for (int i = 0; i < MATRIU_WIDTH; i++) {
    escriureScreenLedStrip();
    ferCorrerScreen();
    delay(50);
  }
}



/*
   Iterar a trabés de les taules de amplades de fonts per trobar la que busquem
*/
boolean cercarFont(char pCaracter) {
  int iCaracter = pCaracter;

  //reinicialitzem les variables de font trobada de la llista
  ampladaFontAEscriure = 0;
  for ( int i = 0; i < 13; i++) {
    fontAEscriure[i] = 0;
  }


  for (byte i = 0; i < QuantesTaulesFonts; i++) {
    cercarFontLletres(i, TotesLesFontsQuantes[i], TotesLesFontsAmplada[i], iCaracter);
    if (ampladaFontAEscriure != 0) break;
  }

  return ampladaFontAEscriure > 0;
}

/*
   Iterar sobre una taula d'una amplada concret de font
*/
void cercarFontLletres(int quinaArray, byte pQuantesLLetres, byte pMidaLletres, int pCaracter) {

  for (byte lletra = 0; lletra < pQuantesLLetres; lletra++) {

    int posIni = (2 /*bytes*/ * lletra * (pMidaLletres + 1)); //apuntem al codi de caràcter
    if (pCaracter ==  pgm_read_word(   TotesLesFonts[quinaArray] + posIni   )    ) {
      posIni = posIni + 2; //Apuntem a la lletra
      ampladaFontAEscriure = pMidaLletres;
      for ( int i = 0; i < ampladaFontAEscriure; i++) {
        fontAEscriure[i] = pgm_read_word(   TotesLesFonts[quinaArray] + posIni + (i * 2)  );
      }
      break;
    }

  }


}

/*

*/
void encuarFontScreen() {

  for (byte i = 0; i < ampladaFontAEscriure; i++) {
    screen[MATRIU_WIDTH + i - 1] = fontAEscriure[i];
  }
  posScreen = ampladaFontAEscriure;
}

/*

*/
void escriureScreenUSB() {
  for (int colunes = 0; colunes < MATRIU_WIDTH + screenOffset; colunes++) {
    for (int bits = 9; bits > -1; bits--) {
      // Compare bits 7-0 in byte
      if (screen[colunes] & (1 << bits)) {
        Serial.print("1");
      }
      else {
        Serial.print(" ");
      }
    }
    Serial.print("\n");
  }
}
/*

*/
void escriureScreenLedStrip() {
  matrix->fillScreen(0);

  for (int colunes = 0; colunes < MATRIU_WIDTH; colunes++) {
    for (int files = 0; files < MATRIU_HEIGHT  ; files++) {
      // Compare bits 7-0 in byte
      if (screen[colunes] & (1 << files)) {
        matrix->drawPixel(colunes, MATRIU_HEIGHT - files - 1, colors[0]);
      } else {
        matrix->drawPixel(colunes, MATRIU_HEIGHT - files - 1, colors[1]);
      }

    }
  }

  matrix->show();

}

/*

*/
void ferCorrerScreen() {
  for (int columna = 0; columna < MATRIU_WIDTH + screenOffset - 1; columna++) {
    screen[columna] = screen[columna + 1];
  }
  screen[MATRIU_WIDTH + screenOffset - 1] = 0;
  posScreen = posScreen - 1;
}



/*
   ONLY FOR DEBUG. WE DON'T USE IT
*/
void escriureLletraSeleccionada() {
  for (int colunes = 0; colunes < ampladaFontAEscriure; colunes++) {
    //Serial.println(fontAEscriure[colunes]);
    for (int bits = 9; bits > -1; bits--) {
      // Compare bits 7-0 in byte
      if (fontAEscriure[colunes] & (1 << bits)) {
        Serial.print("1");
      }
      else {
        Serial.print(" ");
      }
    }
    Serial.print("\n");
  }
}



//-------------------------------------------------------------
//-------------------------------------------------------------
//-------------------------------------------------------------
//-------------------------------------------------------------


/*

*/
boolean EventUSB() {

  if (Serial.available()) {
    //Reinicialitzem del que haguem pogut llegir l'anterior vegada
    inputString = "";

    char inChar = (char)Serial.read();
    while (inChar != '\n') {
      // get the new byte:
      // add it to the inputString:
      inputString += inChar;
      while (not Serial.available()) {
        ;
      }
      inChar = (char)Serial.read();
    }
    stringComplete = true;
    return true;
  }

  return false;
}
