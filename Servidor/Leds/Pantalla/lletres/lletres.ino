#include <stdlib.h>


//https://github.com/adafruit/Adafruit_NeoMatrix
// Only use this functions or Serial will not work:
//https://github.com/adafruit/Adafruit_NeoMatrix/blob/master/Adafruit_NeoMatrix.h
#include <Adafruit_GFX.h>
#include <Adafruit_NeoMatrix.h>
#include <Adafruit_NeoPixel.h>

//generated by the other program. You cal also use main Adafruit letters (less dificult) 
#include "fontProgmem.h"


#define PIN 10
#define MATRIU_WIDTH 29
#define MATRIU_HEIGHT 10

//ALERT: DEFAULT VALUE IS 9600
#define SERIAL_BAUD 115200



//screenOffset must be ONE less than the bigest width letter 
#define screenOffset 12
byte posScreen = 0;
int screen[MATRIU_WIDTH + screenOffset];


//Cadena de caracters rebuda per el USB
//const byte numChars = 3200;
//char inputString[numChars]; // an array to store the received data
String inputString = "";         // a String to hold incoming data
bool stringComplete = false;  // whether the string is complete

//When i found a char to write, i will store there
int  fontAEscriure[13];
byte ampladaFontAEscriure;



Adafruit_NeoMatrix *matrix = new Adafruit_NeoMatrix(MATRIU_WIDTH, MATRIU_HEIGHT, PIN,
                            NEO_MATRIX_BOTTOM     + NEO_MATRIX_RIGHT +
                            NEO_MATRIX_COLUMNS + NEO_MATRIX_ZIGZAG,
                            NEO_GRB            + NEO_KHZ800);
const uint16_t colors[] = {  matrix->Color(255, 0, 0), matrix->Color(0, 255, 0), matrix->Color(0, 0, 255) };



#define LED_BLACK    0

#define LED_RED_VERYLOW   (3 <<  11)
#define LED_RED_LOW     (7 <<  11)
#define LED_RED_MEDIUM    (15 << 11)
#define LED_RED_HIGH    (31 << 11)

#define LED_GREEN_VERYLOW (1 <<  5)   
#define LED_GREEN_LOW     (15 << 5)  
#define LED_GREEN_MEDIUM  (31 << 5)  
#define LED_GREEN_HIGH    (63 << 5)  

#define LED_BLUE_VERYLOW  3
#define LED_BLUE_LOW    7
#define LED_BLUE_MEDIUM   15
#define LED_BLUE_HIGH     31

#define LED_ORANGE_VERYLOW  (LED_RED_VERYLOW + LED_GREEN_VERYLOW)
#define LED_ORANGE_LOW    (LED_RED_LOW     + LED_GREEN_LOW)
#define LED_ORANGE_MEDIUM (LED_RED_MEDIUM  + LED_GREEN_MEDIUM)
#define LED_ORANGE_HIGH   (LED_RED_HIGH    + LED_GREEN_HIGH)

#define LED_PURPLE_VERYLOW  (LED_RED_VERYLOW + LED_BLUE_VERYLOW)
#define LED_PURPLE_LOW    (LED_RED_LOW     + LED_BLUE_LOW)
#define LED_PURPLE_MEDIUM (LED_RED_MEDIUM  + LED_BLUE_MEDIUM)
#define LED_PURPLE_HIGH   (LED_RED_HIGH    + LED_BLUE_HIGH)

#define LED_CYAN_VERYLOW  (LED_GREEN_VERYLOW + LED_BLUE_VERYLOW)
#define LED_CYAN_LOW    (LED_GREEN_LOW     + LED_BLUE_LOW)
#define LED_CYAN_MEDIUM   (LED_GREEN_MEDIUM  + LED_BLUE_MEDIUM)
#define LED_CYAN_HIGH   (LED_GREEN_HIGH    + LED_BLUE_HIGH)

#define LED_WHITE_VERYLOW (LED_RED_VERYLOW + LED_GREEN_VERYLOW + LED_BLUE_VERYLOW)
#define LED_WHITE_LOW   (LED_RED_LOW     + LED_GREEN_LOW     + LED_BLUE_LOW)
#define LED_WHITE_MEDIUM  (LED_RED_MEDIUM  + LED_GREEN_MEDIUM  + LED_BLUE_MEDIUM)
#define LED_WHITE_HIGH    (LED_RED_HIGH    + LED_GREEN_HIGH    + LED_BLUE_HIGH)

/*short matrixOrdenadaX[][MATRIU_WIDTH] =  {
{ 9 , 10  , 29  , 30  , 49  , 50  , 69  , 70  , 89  , 90  , 109 , 110 , 129 , 130 , 149 , 150 , 169 , 170 , 189 , 190 , 209 , 210 , 229 , 230 , 249 , 250 , 269 , 270 , 289 , } ,
{ 8 , 11  , 28  , 31  , 48  , 51  , 68  , 71  , 88  , 91  , 108 , 111 , 128 , 131 , 148 , 151 , 168 , 171 , 188 , 191 , 208 , 211 , 228 , 231 , 248 , 251 , 268 , 271 , 288 , } ,
{ 7 , 12  , 27  , 32  , 47  , 52  , 67  , 72  , 87  , 92  , 107 , 112 , 127 , 132 , 147 , 152 , 167 , 172 , 187 , 192 , 207 , 212 , 227 , 232 , 247 , 252 , 267 , 272 , 287 , } ,
{ 6 , 13  , 26  , 33  , 46  , 53  , 66  , 73  , 86  , 93  , 106 , 113 , 126 , 133 , 146 , 153 , 166 , 173 , 186 , 193 , 206 , 213 , 226 , 233 , 246 , 253 , 266 , 273 , 286 , } ,
{ 5 , 14  , 25  , 34  , 45  , 54  , 65  , 74  , 85  , 94  , 105 , 114 , 125 , 134 , 145 , 154 , 165 , 174 , 185 , 194 , 205 , 214 , 225 , 234 , 245 , 254 , 265 , 274 , 285 , } ,
{ 4 , 15  , 24  , 35  , 44  , 55  , 64  , 75  , 84  , 95  , 104 , 115 , 124 , 135 , 144 , 155 , 164 , 175 , 184 , 195 , 204 , 215 , 224 , 235 , 244 , 255 , 264 , 275 , 284 , } ,
{ 3 , 16  , 23  , 36  , 43  , 56  , 63  , 76  , 83  , 96  , 103 , 116 , 123 , 136 , 143 , 156 , 163 , 176 , 183 , 196 , 203 , 216 , 223 , 236 , 243 , 256 , 263 , 276 , 283 , } ,
{ 2 , 17  , 22  , 37  , 42  , 57  , 62  , 77  , 82  , 97  , 102 , 117 , 122 , 137 , 142 , 157 , 162 , 177 , 182 , 197 , 202 , 217 , 222 , 237 , 242 , 257 , 262 , 277 , 282 , } ,
{ 1 , 18  , 21  , 38  , 41  , 58  , 61  , 78  , 81  , 98  , 101 , 118 , 121 , 138 , 141 , 158 , 161 , 178 , 181 , 198 , 201 , 218 , 221 , 238 , 241 , 258 , 261 , 278 , 281 , } ,
{ 0 , 19  , 20  , 39  , 40  , 59  , 60  , 79  , 80  , 99  , 100 , 119 , 120 , 139 , 140 , 159 , 160 , 179 , 180 , 199 , 200 , 219 , 220 , 239 , 240 , 259 , 260 , 279 , 280 , } ,
};*/


/*

*/
void init_neomatrix() {



  matrix->begin();
  matrix->setTextWrap(false);
  matrix->setBrightness(10);
  //Show withe screen for 3 secons to ensure all is ok at init
  matrix->fillScreen(LED_WHITE_HIGH);
  matrix->show();
  delay(3000);
  matrix->clear();
  matrix->show();
  

  
}

/*
int x = MATRIU_WIDTH;
int pass = 0;
  //
  // Example of how to write using  nomatrix font
  //
  void iteracio_neomatrix(){


  //#include <Fonts/TomThumb.h>
  matrix->setFont(&TomThumb);


  matrix->fillScreen(0);
  matrix->setCursor(x, 1);
  //matrix->setTextSize(1);
  matrix->print(F("P E R E     M I Q U E L"));
  if(--x < int(sizeof("P E R E     M I Q U E L"))*int(-5)) {
    x = matrix->width();
    if(++pass >= 3) pass = 0;
    matrix->setTextColor(colors[pass]);
  }
  matrix->show();
  delay(100);
  }
*/


/*

*/
void setup() {

  Serial.begin(SERIAL_BAUD); 

  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }
  
  init_neomatrix();
  
   Serial.println("Inicialització realitzada");

/*
  while(true){
  
    EventUSB();
  
    if (stringComplete) {
      delay(1000);
      Serial.println("HEM LLEGIT UNA LINIA 1");
      Serial.println(inputString);
      Serial.println(inputString.substring(0,5));
      stringComplete = false;
      if (inputString.substring(0,5) == "inici"){
        Serial.println("sortim");
        break;
        Serial.println("ja no hi som");
      }
    }
  }*/

 
/*
Serial.println("inicialitzem");
  while(true){
  
    EventUSB();
  
    if (stringComplete) {
      delay(1000);
      Serial.println("HEM LLEGIT UNA LINIA");
      Serial.println(inputString);
      stringComplete = false;
      if (inputString == "inici") break;
    }
  }
*/

}






/*-------------------------------------------------------------
                 MAIN FUNCTION
  -------------------------------------------------------------
*/
void loop() {

/*
  matrix->fillScreen(0);  
  for (int files = 0; files < MATRIU_HEIGHT /2; files++) {
    for (int columnes = 0; columnes < MATRIU_WIDTH; columnes++) {
      matrix->drawPixel(columnes,files, LED_WHITE_MEDIUM);
      matrix->show();
      delay(10);

    }
  }*/

  EventUSB();
  if (inputString.substring(0,2) = "t:"){
    inputString = inputString.substring(2);
    writeText();
  }
  

}

void writeText(){  

  if (stringComplete) {
    stringComplete = false;
    delay(500);
    Serial.println(inputString.substring(0,2));
    Serial.println(inputString);
    

    //delay(1000);
    //Serial.println("HEM LLEGIT UNA LINIA");
    //Serial.println(inputString);


    //escribim la frase rebuda
    for (auto i : inputString)  {
      if (cercarFont((char)i)) {
        encuarFontScreen();
        while (posScreen > 0) {
//          escriureScreenUSB();
          escriureScreenLedStrip();
          ferCorrerScreen();
          delay(50);
        }

        if (EventUSB()) {
          break;
        }
      }
    }
    //move last caracter until the end, althought another instruction arribes
    for (int i = 0; i < MATRIU_WIDTH; i++) {
      escriureScreenLedStrip();
      ferCorrerScreen();
      delay(50);
    }

    //If don't have a new instruction that cuts this one
    if (!stringComplete) {
      //clear the written string and ask for more text
      inputString = "";
      Serial.println("+");
    }


  }

}




/*
   Iterar a trabés de les taules de amplades de fonts per trobar la que busquem
*/
boolean cercarFont(char pCaracter) {
  int iCaracter = pCaracter;

  //reinicialitzem les variables de font trobada de la llista
  ampladaFontAEscriure = 0;
  for ( int i = 0; i < 13; i++) {
    fontAEscriure[i] = 0;
  }


  for (byte i = 0; i < QuantesTaulesFonts; i++) {
    cercarFontLletres(i, TotesLesFontsQuantes[i], TotesLesFontsAmplada[i], iCaracter);
    if (ampladaFontAEscriure != 0) break;
  }

  return ampladaFontAEscriure > 0;
}

/*
   Iterar sobre una taula d'una amplada concret de font
*/
void cercarFontLletres(int quinaArray, byte pQuantesLLetres, byte pMidaLletres, int pCaracter) {

  for (byte lletra = 0; lletra < pQuantesLLetres; lletra++) {

    int posIni = (2 /*bytes*/ * lletra * (pMidaLletres + 1)); //apuntem al codi de caràcter
    if (pCaracter ==  pgm_read_word(   TotesLesFonts[quinaArray] + posIni   )    ) {
      posIni = posIni + 2; //Apuntem a la lletra
      ampladaFontAEscriure = pMidaLletres;
      for ( int i = 0; i < ampladaFontAEscriure; i++) {
        fontAEscriure[i] = pgm_read_word(   TotesLesFonts[quinaArray] + posIni + (i * 2)  );
      }
      break;
    }

  }


}

/*

*/
void encuarFontScreen() {

  for (byte i = 0; i < ampladaFontAEscriure; i++) {
    screen[MATRIU_WIDTH + i - 1] = fontAEscriure[i];
  }
  posScreen = ampladaFontAEscriure;
}

/*

*/
void escriureScreenUSB() {
  for (int colunes = 0; colunes < MATRIU_WIDTH + screenOffset; colunes++) {
    for (int bits = 9; bits > -1; bits--) {
      // Compare bits 7-0 in byte
      if (screen[colunes] & (1 << bits)) {
        Serial.print("1");
      }
      else {
        Serial.print(" ");
      }
    }
    Serial.print("\n");
  }
}
/*

*/
void escriureScreenLedStrip() {

  //matrix->setCursor(x, 1);
  matrix->fillScreen(0);


  for (int colunes = 0; colunes < MATRIU_WIDTH; colunes++) {
    for (int files = 0; files < MATRIU_HEIGHT  ; files++) {
      // Compare bits 7-0 in byte
      if (screen[colunes] & (1 << files)) {
        matrix->drawPixel(colunes,MATRIU_HEIGHT - files - 1, LED_WHITE_HIGH);
      } else {
        matrix->drawPixel(colunes,MATRIU_HEIGHT - files - 1, LED_RED_VERYLOW);
      }

    }
  }

  matrix->show();

}

/*

*/
void ferCorrerScreen() {
  for (int columna = 0; columna < MATRIU_WIDTH + screenOffset - 1; columna++) {
    screen[columna] = screen[columna + 1];
  }
  screen[MATRIU_WIDTH + screenOffset - 1] = 0;
  posScreen = posScreen - 1;
}



/*
   ONLY FOR DEBUG. WE DON'T USE IT
*/
void escriureLletraSeleccionada() {
  for (int colunes = 0; colunes < ampladaFontAEscriure; colunes++) {
    //Serial.println(fontAEscriure[colunes]);
    for (int bits = 9; bits > -1; bits--) {
      // Compare bits 7-0 in byte
      if (fontAEscriure[colunes] & (1 << bits)) {
        Serial.print("1");
      }
      else {
        Serial.print(" ");
      }
    }
    Serial.print("\n");
  }
}



/*
  SerialEvent occurs whenever a new data comes in the hardware serial RX. This
  routine is run between each time loop() runs, so using delay inside loop can
  delay response. Multiple bytes of data may be available.

  NOTE: The serialEvent() feature is not available on the Leonardo, Micro, or
  other ATmega32U4 based boards.
*/

boolean EventUSB() {
  
  if (Serial.available()) {
    //Reinicialitzem del que haguem pogut llegir l'anterior vegada
    inputString = "";

    char inChar = (char)Serial.read();
    while (inChar != '\n') {
      // get the new byte:

      // add it to the inputString:
      inputString += inChar;
      while(not Serial.available()) {;}
      inChar = (char)Serial.read();
      // if the incoming character is a newline, set a flag so the main loop can
      // do something about it:
      //Serial.print("REBUT:" + inChar);
      // if (inChar == '\n' and stringComplete == false) {
      //stringComplete = true;
      //delay(1000);
      //Serial.println("HEM LLEGIT UNA LINIA");
      //Serial.println(inputString);
    }
    stringComplete = true;
    return true;
  }
  
  return false;
}
/*


void EventUSB() {
  static byte ndx = 0;
  char endMarker = '\n';
  char rc;

  if (Serial.available() > 0) {
    while (Serial.available() > 0 && stringComplete == false) {
      rc = Serial.read();

      if (rc != endMarker) {
        inputString[ndx] = rc;
        ndx++;
        if (ndx >= numChars) {
          ndx = numChars - 1;
        }
      }
      else {
        inputString[ndx] = '\0'; // terminate the string
        ndx = 0;
        stringComplete = true;
      }
    }
  }
}
*/
