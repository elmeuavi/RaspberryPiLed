#include <stdlib.h>


//https://github.com/adafruit/Adafruit_NeoMatrix
// Only use this functions or Serial will not work:
//https://github.com/adafruit/Adafruit_NeoMatrix/blob/master/Adafruit_NeoMatrix.h
#include <Adafruit_GFX.h>
#include <Adafruit_NeoMatrix.h>
#include <Adafruit_NeoPixel.h>

#include "smileytongue24.h"

//generated by the other program. You cal also use main Adafruit letters (less dificult)
#include "fontProgmem.h"

#define PIN 10
#define MATRIU_WIDTH 29
#define MATRIU_HEIGHT 10

//ALERT: DEFAULT VALUE IS 9600
#define SERIAL_BAUD 115200



//screenOffset must be ONE less than the bigest width letter
#define screenOffset 12
byte posScreen = 0;
int screen[MATRIU_WIDTH + screenOffset];


//Cadena de caracters rebuda per el USB
String inputString = "";         // a String to hold incoming data
bool stringComplete = false;     // whether the string is complete

//When i found a char to write, i will store there
int  fontAEscriure[13];
byte ampladaFontAEscriure;



Adafruit_NeoMatrix *matrix = new Adafruit_NeoMatrix(MATRIU_WIDTH, MATRIU_HEIGHT, PIN,
    NEO_MATRIX_BOTTOM     + NEO_MATRIX_RIGHT +
    NEO_MATRIX_COLUMNS + NEO_MATRIX_ZIGZAG,
    NEO_GRB            + NEO_KHZ800);
const uint16_t colors[] = {  matrix->Color(255, 0, 0), matrix->Color(0, 255, 0), matrix->Color(0, 0, 255) };



#define LED_BLACK    0

#define LED_RED_VERYLOW   (3 <<  11)
#define LED_RED_LOW     (7 <<  11)
#define LED_RED_MEDIUM    (15 << 11)
#define LED_RED_HIGH    (31 << 11)

#define LED_GREEN_VERYLOW (1 <<  5)
#define LED_GREEN_LOW     (15 << 5)
#define LED_GREEN_MEDIUM  (31 << 5)
#define LED_GREEN_HIGH    (63 << 5)

#define LED_BLUE_VERYLOW  3
#define LED_BLUE_LOW    7
#define LED_BLUE_MEDIUM   15
#define LED_BLUE_HIGH     31

#define LED_ORANGE_VERYLOW  (LED_RED_VERYLOW + LED_GREEN_VERYLOW)
#define LED_ORANGE_LOW    (LED_RED_LOW     + LED_GREEN_LOW)
#define LED_ORANGE_MEDIUM (LED_RED_MEDIUM  + LED_GREEN_MEDIUM)
#define LED_ORANGE_HIGH   (LED_RED_HIGH    + LED_GREEN_HIGH)

#define LED_PURPLE_VERYLOW  (LED_RED_VERYLOW + LED_BLUE_VERYLOW)
#define LED_PURPLE_LOW    (LED_RED_LOW     + LED_BLUE_LOW)
#define LED_PURPLE_MEDIUM (LED_RED_MEDIUM  + LED_BLUE_MEDIUM)
#define LED_PURPLE_HIGH   (LED_RED_HIGH    + LED_BLUE_HIGH)

#define LED_CYAN_VERYLOW  (LED_GREEN_VERYLOW + LED_BLUE_VERYLOW)
#define LED_CYAN_LOW    (LED_GREEN_LOW     + LED_BLUE_LOW)
#define LED_CYAN_MEDIUM   (LED_GREEN_MEDIUM  + LED_BLUE_MEDIUM)
#define LED_CYAN_HIGH   (LED_GREEN_HIGH    + LED_BLUE_HIGH)

#define LED_WHITE_VERYLOW (LED_RED_VERYLOW + LED_GREEN_VERYLOW + LED_BLUE_VERYLOW)
#define LED_WHITE_LOW   (LED_RED_LOW     + LED_GREEN_LOW     + LED_BLUE_LOW)
#define LED_WHITE_MEDIUM  (LED_RED_MEDIUM  + LED_GREEN_MEDIUM  + LED_BLUE_MEDIUM)
#define LED_WHITE_HIGH    (LED_RED_HIGH    + LED_GREEN_HIGH    + LED_BLUE_HIGH)



static const uint16_t PROGMEM
// These bitmaps were written for a backend that only supported
// 4 bits per color with Blue/Green/Red ordering while neomatrix
// uses native 565 color mapping as RGB.
// I'm leaving the arrays as is because it's easier to read
// which color is what when separated on a 4bit boundary
// The demo code will modify the arrays at runtime to be compatible
// with the neomatrix color ordering and bit depth.
RGB_bmp[][64] = {
  // 00: blue, blue/red, red, red/green, green, green/blue, blue, white
  { 0x100, 0x200, 0x300, 0x400, 0x600, 0x800, 0xA00, 0xF00,
    0x101, 0x202, 0x303, 0x404, 0x606, 0x808, 0xA0A, 0xF0F,
    0x001, 0x002, 0x003, 0x004, 0x006, 0x008, 0x00A, 0x00F,
    0x011, 0x022, 0x033, 0x044, 0x066, 0x088, 0x0AA, 0x0FF,
    0x010, 0x020, 0x030, 0x040, 0x060, 0x080, 0x0A0, 0x0F0,
    0x110, 0x220, 0x330, 0x440, 0x660, 0x880, 0xAA0, 0xFF0,
    0x100, 0x200, 0x300, 0x400, 0x600, 0x800, 0xA00, 0xF00,
    0x111, 0x222, 0x333, 0x444, 0x666, 0x888, 0xAAA, 0xFFF,
  },

  // 01: grey to white
  { 0x111, 0x222, 0x333, 0x555, 0x777, 0x999, 0xAAA, 0xFFF,
    0x222, 0x222, 0x333, 0x555, 0x777, 0x999, 0xAAA, 0xFFF,
    0x333, 0x333, 0x333, 0x555, 0x777, 0x999, 0xAAA, 0xFFF,
    0x555, 0x555, 0x555, 0x555, 0x777, 0x999, 0xAAA, 0xFFF,
    0x777, 0x777, 0x777, 0x777, 0x777, 0x999, 0xAAA, 0xFFF,
    0x999, 0x999, 0x999, 0x999, 0x999, 0x999, 0xAAA, 0xFFF,
    0xAAA, 0xAAA, 0xAAA, 0xAAA, 0xAAA, 0xAAA, 0xAAA, 0xFFF,
    0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF,
  },

  // 02: low red to high red
  { 0x001, 0x002, 0x003, 0x005, 0x007, 0x009, 0x00A, 0x00F,
    0x002, 0x002, 0x003, 0x005, 0x007, 0x009, 0x00A, 0x00F,
    0x003, 0x003, 0x003, 0x005, 0x007, 0x009, 0x00A, 0x00F,
    0x005, 0x005, 0x005, 0x005, 0x007, 0x009, 0x00A, 0x00F,
    0x007, 0x007, 0x007, 0x007, 0x007, 0x009, 0x00A, 0x00F,
    0x009, 0x009, 0x009, 0x009, 0x009, 0x009, 0x00A, 0x00F,
    0x00A, 0x00A, 0x00A, 0x00A, 0x00A, 0x00A, 0x00A, 0x00F,
    0x00F, 0x00F, 0x00F, 0x00F, 0x00F, 0x00F, 0x00F, 0x00F,
  },

  // 03: low green to high green
  { 0x010, 0x020, 0x030, 0x050, 0x070, 0x090, 0x0A0, 0x0F0,
    0x020, 0x020, 0x030, 0x050, 0x070, 0x090, 0x0A0, 0x0F0,
    0x030, 0x030, 0x030, 0x050, 0x070, 0x090, 0x0A0, 0x0F0,
    0x050, 0x050, 0x050, 0x050, 0x070, 0x090, 0x0A0, 0x0F0,
    0x070, 0x070, 0x070, 0x070, 0x070, 0x090, 0x0A0, 0x0F0,
    0x090, 0x090, 0x090, 0x090, 0x090, 0x090, 0x0A0, 0x0F0,
    0x0A0, 0x0A0, 0x0A0, 0x0A0, 0x0A0, 0x0A0, 0x0A0, 0x0F0,
    0x0F0, 0x0F0, 0x0F0, 0x0F0, 0x0F0, 0x0F0, 0x0F0, 0x0F0,
  },

  // 04: low blue to high blue
  { 0x100, 0x200, 0x300, 0x500, 0x700, 0x900, 0xA00, 0xF00,
    0x200, 0x200, 0x300, 0x500, 0x700, 0x900, 0xA00, 0xF00,
    0x300, 0x300, 0x300, 0x500, 0x700, 0x900, 0xA00, 0xF00,
    0x500, 0x500, 0x500, 0x500, 0x700, 0x900, 0xA00, 0xF00,
    0x700, 0x700, 0x700, 0x700, 0x700, 0x900, 0xA00, 0xF00,
    0x900, 0x900, 0x900, 0x900, 0x900, 0x900, 0xA00, 0xF00,
    0xA00, 0xA00, 0xA00, 0xA00, 0xA00, 0xA00, 0xA00, 0xF00,
    0xF00, 0xF00, 0xF00, 0xF00, 0xF00, 0xF00, 0xF00, 0xF00,
  },

  // 05: 1 black, 2R, 2O, 2G, 1B with 4 blue lines rising right
  { 0x000, 0x200, 0x000, 0x400, 0x000, 0x800, 0x000, 0xF00,
    0x000, 0x201, 0x002, 0x403, 0x004, 0x805, 0x006, 0xF07,
    0x008, 0x209, 0x00A, 0x40B, 0x00C, 0x80D, 0x00E, 0xF0F,
    0x000, 0x211, 0x022, 0x433, 0x044, 0x855, 0x066, 0xF77,
    0x088, 0x299, 0x0AA, 0x4BB, 0x0CC, 0x8DD, 0x0EE, 0xFFF,
    0x000, 0x210, 0x020, 0x430, 0x040, 0x850, 0x060, 0xF70,
    0x080, 0x290, 0x0A0, 0x4B0, 0x0C0, 0x8D0, 0x0E0, 0xFF0,
    0x000, 0x200, 0x000, 0x500, 0x000, 0x800, 0x000, 0xF00,
  },

  // 06: 4 lines of increasing red and then green
  { 0x000, 0x000, 0x001, 0x001, 0x002, 0x002, 0x003, 0x003,
    0x004, 0x004, 0x005, 0x005, 0x006, 0x006, 0x007, 0x007,
    0x008, 0x008, 0x009, 0x009, 0x00A, 0x00A, 0x00B, 0x00B,
    0x00C, 0x00C, 0x00D, 0x00D, 0x00E, 0x00E, 0x00F, 0x00F,
    0x000, 0x000, 0x010, 0x010, 0x020, 0x020, 0x030, 0x030,
    0x040, 0x040, 0x050, 0x050, 0x060, 0x060, 0x070, 0x070,
    0x080, 0x080, 0x090, 0x090, 0x0A0, 0x0A0, 0x0B0, 0x0B0,
    0x0C0, 0x0C0, 0x0D0, 0x0D0, 0x0E0, 0x0E0, 0x0F0, 0x0F0,
  },

  // 07: 4 lines of increasing red and then blue
  { 0x000, 0x000, 0x001, 0x001, 0x002, 0x002, 0x003, 0x003,
    0x004, 0x004, 0x005, 0x005, 0x006, 0x006, 0x007, 0x007,
    0x008, 0x008, 0x009, 0x009, 0x00A, 0x00A, 0x00B, 0x00B,
    0x00C, 0x00C, 0x00D, 0x00D, 0x00E, 0x00E, 0x00F, 0x00F,
    0x000, 0x000, 0x100, 0x100, 0x200, 0x200, 0x300, 0x300,
    0x400, 0x400, 0x500, 0x500, 0x600, 0x600, 0x700, 0x700,
    0x800, 0x800, 0x900, 0x900, 0xA00, 0xA00, 0xB00, 0xB00,
    0xC00, 0xC00, 0xD00, 0xD00, 0xE00, 0xE00, 0xF00, 0xF00,
  },

  // 08: criss cross of green and red with diagonal blue.
  { 0xF00, 0x001, 0x003, 0x005, 0x007, 0x00A, 0x00F, 0x000,
    0x020, 0xF21, 0x023, 0x025, 0x027, 0x02A, 0x02F, 0x020,
    0x040, 0x041, 0xF43, 0x045, 0x047, 0x04A, 0x04F, 0x040,
    0x060, 0x061, 0x063, 0xF65, 0x067, 0x06A, 0x06F, 0x060,
    0x080, 0x081, 0x083, 0x085, 0xF87, 0x08A, 0x08F, 0x080,
    0x0A0, 0x0A1, 0x0A3, 0x0A5, 0x0A7, 0xFAA, 0x0AF, 0x0A0,
    0x0F0, 0x0F1, 0x0F3, 0x0F5, 0x0F7, 0x0FA, 0xFFF, 0x0F0,
    0x000, 0x001, 0x003, 0x005, 0x007, 0x00A, 0x00F, 0xF00,
  },

  // 09: 2 lines of green, 2 red, 2 orange, 2 green
  { 0x0F0, 0x0F0, 0x0FF, 0x0FF, 0x00F, 0x00F, 0x0F0, 0x0F0,
    0x0F0, 0x0F0, 0x0FF, 0x0FF, 0x00F, 0x00F, 0x0F0, 0x0F0,
    0x0F0, 0x0F0, 0x0FF, 0x0FF, 0x00F, 0x00F, 0x0F0, 0x0F0,
    0x0F0, 0x0F0, 0x0FF, 0x0FF, 0x00F, 0x00F, 0x0F0, 0x0F0,
    0x0F0, 0x0F0, 0x0FF, 0x0FF, 0x00F, 0x00F, 0x0F0, 0x0F0,
    0x0F0, 0x0F0, 0x0FF, 0x0FF, 0x00F, 0x00F, 0x0F0, 0x0F0,
    0x0F0, 0x0F0, 0x0FF, 0x0FF, 0x00F, 0x00F, 0x0F0, 0x0F0,
    0x0F0, 0x0F0, 0x0FF, 0x0FF, 0x00F, 0x00F, 0x0F0, 0x0F0,
  },

  // 10: multicolor smiley face
  { 0x000, 0x000, 0x00F, 0x00F, 0x00F, 0x00F, 0x000, 0x000,
    0x000, 0x00F, 0x000, 0x000, 0x000, 0x000, 0x00F, 0x000,
    0x00F, 0x000, 0xF00, 0x000, 0x000, 0xF00, 0x000, 0x00F,
    0x00F, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x00F,
    0x00F, 0x000, 0x0F0, 0x000, 0x000, 0x0F0, 0x000, 0x00F,
    0x00F, 0x000, 0x000, 0x0F4, 0x0F3, 0x000, 0x000, 0x00F,
    0x000, 0x00F, 0x000, 0x000, 0x000, 0x000, 0x00F, 0x000,
    0x000, 0x000, 0x00F, 0x00F, 0x00F, 0x00F, 0x000, 0x000,
  },
};


/*

*/
void init_neomatrix() {

  matrix->begin();
  matrix->setTextWrap(false);
  matrix->setBrightness(10);
  //Show withe screen for 3 secons to ensure all is ok at init
  matrix->fillScreen(LED_WHITE_HIGH);
  matrix->show();
  delay(3000);
  matrix->clear();
  matrix->show();

}

/*
  int x = MATRIU_WIDTH;
  int pass = 0;
  //
  // Example of how to write using  nomatrix font
  //
  void iteracio_neomatrix(){


  //#include <Fonts/TomThumb.h>
  matrix->setFont(&TomThumb);


  matrix->fillScreen(0);
  matrix->setCursor(x, 1);
  //matrix->setTextSize(1);
  matrix->print(F("P E R E     M I Q U E L"));
  if(--x < int(sizeof("P E R E     M I Q U E L"))*int(-5)) {
    x = matrix->width();
    if(++pass >= 3) pass = 0;
    matrix->setTextColor(colors[pass]);
  }
  matrix->show();
  delay(100);
  }
*/


/*

*/
void setup() {

  Serial.begin(SERIAL_BAUD);

  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }

  init_neomatrix();

  Serial.println("Inicialització realitzada");
}






/*-------------------------------------------------------------
                 MAIN FUNCTION
  -------------------------------------------------------------
*/
void loop() {

  /*
    matrix->fillScreen(0);
    for (int files = 0; files < MATRIU_HEIGHT /2; files++) {
      for (int columnes = 0; columnes < MATRIU_WIDTH; columnes++) {
        matrix->drawPixel(columnes,files, LED_WHITE_MEDIUM);
        matrix->show();
        delay(10);

      }
    }*/

  EventUSB();
  


  if (stringComplete) {
    stringComplete = false;


    //WRITE A TEXT
    if (inputString.substring(0, 2).equals("t:")) {
      Serial.println("Rebut text");
      String enviarString = inputString.substring(2);
      inputString = "";
      writeText(enviarString);

      //If don't have a new instruction that cuts this one
      if (!stringComplete) {
        //ask for more text
        Serial.println("+");
      }


      
    }else if (inputString.substring(0, 6).equals("smile:")) {
      Serial.println("Rebut smile");
      inputString = "";  
      display_panOrBounceBitmap(8);


      
    }else {
      Serial.println("Rebut desconegut");
      Serial.println(inputString.substring(0, 6));
    }
  }


}



//-------------------------------------------------------------
//-------------------------------------------------------------
//-------------------------------------------------------------
//-------------------------------------------------------------




// Scroll within big bitmap so that all if it becomes visible or bounce a small one.
// If the bitmap is bigger in one dimension and smaller in the other one, it will
// be both panned and bounced in the appropriate dimensions.
void display_panOrBounceBitmap (uint8_t bitmapSize) {
  // keep integer math, deal with values 16 times too big
  // start by showing upper left of big bitmap or centering if the display is big
  int16_t xf = max(0, (MATRIU_WIDTH - bitmapSize) / 2) << 4;
  int16_t yf = max(0, (MATRIU_HEIGHT - bitmapSize) / 2) << 4;
  // scroll speed in 1/16th
  int16_t xfc = 6;
  int16_t yfc = 3;
  // scroll down and right by moving upper left corner off screen
  // more up and left (which means negative numbers)
  int16_t xfdir = -1;
  int16_t yfdir = -1;

  for (uint16_t i = 1; i < 500; i++) {
    bool updDir = false;

    // Get actual x/y by dividing by 16.
    int16_t x = xf >> 4;
    int16_t y = yf >> 4;

    matrix->clear();
    // bounce 8x8 tri color smiley face around the screen
    if (bitmapSize == 8) fixdrawRGBBitmap(x, y, RGB_bmp[10], 8, 8);
    // pan 24x24 pixmap
    if (bitmapSize == 24) matrix->drawRGBBitmap(x, y, (const uint16_t *) bitmap24, bitmapSize, bitmapSize);
#ifdef BM32
    if (bitmapSize == 32) matrix->drawRGBBitmap(x, y, (const uint16_t *) bitmap32, bitmapSize, bitmapSize);
#endif
    matrix->show();

    // Only pan if the display size is smaller than the pixmap
    // but not if the difference is too small or it'll look bad.
    if (bitmapSize - MATRIU_WIDTH > 2) {
      xf += xfc * xfdir;
      if (xf >= 0)                      {
        xfdir = -1;
        updDir = true ;
      };
      // we don't go negative past right corner, go back positive
      if (xf <= ((MATRIU_WIDTH - bitmapSize) << 4)) {
        xfdir = 1;
        updDir = true ;
      };
    }
    if (bitmapSize - MATRIU_HEIGHT > 2) {
      yf += yfc * yfdir;
      // we shouldn't display past left corner, reverse direction.
      if (yf >= 0)                      {
        yfdir = -1;
        updDir = true ;
      };
      if (yf <= ((MATRIU_HEIGHT - bitmapSize) << 4)) {
        yfdir = 1;
        updDir = true ;
      };
    }
    // only bounce a pixmap if it's smaller than the display size
    if (MATRIU_WIDTH > bitmapSize) {
      xf += xfc * xfdir;
      // Deal with bouncing off the 'walls'
      if (xf >= (MATRIU_WIDTH - bitmapSize) << 4) {
        xfdir = -1;
        updDir = true ;
      };
      if (xf <= 0)           {
        xfdir =  1;
        updDir = true ;
      };
    }
    if (MATRIU_HEIGHT > bitmapSize) {
      yf += yfc * yfdir;
      if (yf >= (MATRIU_HEIGHT - bitmapSize) << 4) {
        yfdir = -1;
        updDir = true ;
      };
      if (yf <= 0)           {
        yfdir =  1;
        updDir = true ;
      };
    }

    //if (updDir) {
      // Add -1, 0 or 1 but bind result to 1 to 1.
      // Let's take 3 is a minimum speed, otherwise it's too slow.
    //  xfc = constrain(xfc + random(-1, 2), 3, 16);
    //  yfc = constrain(xfc + random(-1, 2), 3, 16);
    //}
    delay(30);
  }
}

// Convert a BGR 4/4/4 bitmap to RGB 5/6/5 used by Adafruit_GFX
void fixdrawRGBBitmap(int16_t x, int16_t y, const uint16_t *bitmap, int16_t w, int16_t h) {
  // work around "a15 cannot be used in asm here" compiler bug when using an array on ESP8266
  // uint16_t RGB_bmp_fixed[w * h];
  static uint16_t *RGB_bmp_fixed = (uint16_t *) malloc( w * h * 2);
  for (uint16_t pixel = 0; pixel < w * h; pixel++) {
    uint8_t r, g, b;
    uint16_t color = pgm_read_word(bitmap + pixel);

    //Serial.print(color, HEX);
    b = (color & 0xF00) >> 8;
    g = (color & 0x0F0) >> 4;
    r = color & 0x00F;
    //Serial.print(" ");
    //Serial.print(b);
    //Serial.print("/");
    //Serial.print(g);
    //Serial.print("/");
    //Serial.print(r);
    //Serial.print(" -> ");
    // expand from 4/4/4 bits per color to 5/6/5
    b = map(b, 0, 15, 0, 31);
    g = map(g, 0, 15, 0, 63);
    r = map(r, 0, 15, 0, 31);
    //Serial.print(r);
    //Serial.print("/");
    //Serial.print(g);
    //Serial.print("/");
    //Serial.print(b);
    RGB_bmp_fixed[pixel] = (r << 11) + (g << 5) + b;
    //Serial.print(" -> ");
    //Serial.println(RGB_bmp_fixed[pixel], HEX);
  }
  matrix->drawRGBBitmap(x, y, RGB_bmp_fixed, w, h);
}



//-------------------------------------------------------------
//-------------------------------------------------------------
//-------------------------------------------------------------
//-------------------------------------------------------------



void writeText(String pFraseRebuda) {

  for (auto i : pFraseRebuda)  {
    if (cercarFont((char)i)) {
      encuarFontScreen();
      while (posScreen > 0) {
        //Only for debug
        //escriureScreenUSB();
        escriureScreenLedStrip();
        ferCorrerScreen();
        delay(50);
      }

      if (EventUSB()) {
        break;
      }
    }
  }
  //move last caracter until the end, althought another instruction arribes
  for (int i = 0; i < MATRIU_WIDTH; i++) {
    escriureScreenLedStrip();
    ferCorrerScreen();
    delay(50);
  }
}




/*
   Iterar a trabés de les taules de amplades de fonts per trobar la que busquem
*/
boolean cercarFont(char pCaracter) {
  int iCaracter = pCaracter;

  //reinicialitzem les variables de font trobada de la llista
  ampladaFontAEscriure = 0;
  for ( int i = 0; i < 13; i++) {
    fontAEscriure[i] = 0;
  }


  for (byte i = 0; i < QuantesTaulesFonts; i++) {
    cercarFontLletres(i, TotesLesFontsQuantes[i], TotesLesFontsAmplada[i], iCaracter);
    if (ampladaFontAEscriure != 0) break;
  }

  return ampladaFontAEscriure > 0;
}

/*
   Iterar sobre una taula d'una amplada concret de font
*/
void cercarFontLletres(int quinaArray, byte pQuantesLLetres, byte pMidaLletres, int pCaracter) {

  for (byte lletra = 0; lletra < pQuantesLLetres; lletra++) {

    int posIni = (2 /*bytes*/ * lletra * (pMidaLletres + 1)); //apuntem al codi de caràcter
    if (pCaracter ==  pgm_read_word(   TotesLesFonts[quinaArray] + posIni   )    ) {
      posIni = posIni + 2; //Apuntem a la lletra
      ampladaFontAEscriure = pMidaLletres;
      for ( int i = 0; i < ampladaFontAEscriure; i++) {
        fontAEscriure[i] = pgm_read_word(   TotesLesFonts[quinaArray] + posIni + (i * 2)  );
      }
      break;
    }

  }


}

/*

*/
void encuarFontScreen() {

  for (byte i = 0; i < ampladaFontAEscriure; i++) {
    screen[MATRIU_WIDTH + i - 1] = fontAEscriure[i];
  }
  posScreen = ampladaFontAEscriure;
}

/*

*/
void escriureScreenUSB() {
  for (int colunes = 0; colunes < MATRIU_WIDTH + screenOffset; colunes++) {
    for (int bits = 9; bits > -1; bits--) {
      // Compare bits 7-0 in byte
      if (screen[colunes] & (1 << bits)) {
        Serial.print("1");
      }
      else {
        Serial.print(" ");
      }
    }
    Serial.print("\n");
  }
}
/*

*/
void escriureScreenLedStrip() {

  //matrix->setCursor(x, 1);
  matrix->fillScreen(0);


  for (int colunes = 0; colunes < MATRIU_WIDTH; colunes++) {
    for (int files = 0; files < MATRIU_HEIGHT  ; files++) {
      // Compare bits 7-0 in byte
      if (screen[colunes] & (1 << files)) {
        matrix->drawPixel(colunes, MATRIU_HEIGHT - files - 1, LED_WHITE_HIGH);
      } else {
        matrix->drawPixel(colunes, MATRIU_HEIGHT - files - 1, LED_RED_VERYLOW);
      }

    }
  }

  matrix->show();

}

/*

*/
void ferCorrerScreen() {
  for (int columna = 0; columna < MATRIU_WIDTH + screenOffset - 1; columna++) {
    screen[columna] = screen[columna + 1];
  }
  screen[MATRIU_WIDTH + screenOffset - 1] = 0;
  posScreen = posScreen - 1;
}



/*
   ONLY FOR DEBUG. WE DON'T USE IT
*/
void escriureLletraSeleccionada() {
  for (int colunes = 0; colunes < ampladaFontAEscriure; colunes++) {
    //Serial.println(fontAEscriure[colunes]);
    for (int bits = 9; bits > -1; bits--) {
      // Compare bits 7-0 in byte
      if (fontAEscriure[colunes] & (1 << bits)) {
        Serial.print("1");
      }
      else {
        Serial.print(" ");
      }
    }
    Serial.print("\n");
  }
}



//-------------------------------------------------------------
//-------------------------------------------------------------
//-------------------------------------------------------------
//-------------------------------------------------------------


/*

*/
boolean EventUSB() {

  if (Serial.available()) {
    //Reinicialitzem del que haguem pogut llegir l'anterior vegada
    inputString = "";

    char inChar = (char)Serial.read();
    while (inChar != '\n') {
      // get the new byte:
      // add it to the inputString:
      inputString += inChar;
      while (not Serial.available()) {
        ;
      }
      inChar = (char)Serial.read();
    }
    stringComplete = true;
    return true;
  }

  return false;
}
